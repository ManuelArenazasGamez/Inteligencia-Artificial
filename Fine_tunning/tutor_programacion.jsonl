{"id": 1, "concepto": "Algoritmo de ordenamiento", "pregunta": "¿Cuál es el algoritmo de ordenamiento más eficiente para listas pequeñas?", "respuesta": "Para listas pequeñas, el algoritmo de ordenamiento por burbuja (Bubble Sort) es a menudo suficiente y puede ser más rápido debido a la menor sobrecarga.", "dificultad": "facil", "tema": "ordenamiento", "tags": ["ordenamiento", "burbuja", "eficiencia"]}
{"id": 2, "concepto": "Búsqueda binaria", "pregunta": "¿Cuándo se utiliza la búsqueda binaria?", "respuesta": "La búsqueda binaria es efectiva cuando la lista está ordenada y se necesita encontrar un elemento específico de manera eficiente.", "dificultad": "medio", "tema": "búsqueda", "tags": ["búsqueda", "binaria", "ordenamiento"]}
{"id": 3, "concepto": "Recursión", "pregunta": "¿Qué es la recursión en programación?", "respuesta": "La recursión es una técnica donde una función se llama a sí misma dentro de su propia definición. Es útil para resolver problemas que pueden dividirse en subproblemas más pequeños del mismo tipo.", "dificultad": "medio", "tema": "estructuras de control", "tags": ["estructuras de control", "recursión", "funciones"]}
{"id": 4, "concepto": "Algoritmo de Dijkstra", "pregunta": "¿Cuál es el propósito del algoritmo de Dijkstra?", "respuesta": "El algoritmo de Dijkstra se utiliza para encontrar la ruta más corta entre dos nodos en un grafo ponderado.", "dificultad": "medio", "tema": "grafos", "tags": ["grafos", "dijkstra", "ruta más corta"]}
{"id": 5, "concepto": "Algoritmo de ordenamiento Merge Sort", "pregunta": "¿Cómo funciona el algoritmo Merge Sort?", "respuesta": "Merge Sort funciona dividiendo recursivamente la lista en sublistas más pequeñas, ordenando estas sublistas y luego combinando (merging) las sublistas ordenadas para producir una lista ordenada final.", "dificultad": "medio", "tema": "ordenamiento", "tags": ["ordenamiento", "merge sort", "eficiencia"]}
{"id": 6, "concepto": "Recursión - Ejemplo", "pregunta": "Escribir una función recursiva para calcular el factorial de un número.", "respuesta": "```python\ndef factorial(n):\n  if n == 0:\n    return 1\n  else:\n    return n * factorial(n-1)\n```", "dificultad": "medio", "tema": "estructuras de control", "tags": ["recursión", "factorial", "funciones"]}
{"id": 7, "concepto": "Algoritmos de Grafos - Visitas", "pregunta": "¿Qué es una visita en un grafo?", "respuesta": "Una visita (o recorrido) en un grafo es una secuencia de nodos que sigue un conjunto de reglas.  Hay muchos tipos, como DFS y BFS.", "dificultad": "medio", "tema": "grafos", "tags": ["grafos", "dfs", "bfs"]}
{"id": 8, "concepto": "Ordenamiento Quick Sort", "pregunta": "¿Cuál es el corazón del Quick Sort?", "respuesta": "El Quick Sort selecciona un elemento como pivote y particiona la lista en dos sublistas: elementos menores que el pivote y elementos mayores que el pivote.", "dificultad": "medio", "tema": "ordenamiento", "tags": ["ordenamiento", "quick sort", "eficiencia"]}
{"id": 9, "concepto": "Algoritmos de Grafos - DFS", "pregunta": "¿Qué es DFS y cómo funciona?", "respuesta": "DFS (Depth-First Search) es un algoritmo de recorrido de grafos que explora lo más posible a lo largo de cada rama antes de retroceder.  Utiliza una pila implícita.", "dificultad": "medio", "tema": "grafos", "tags": ["grafos", "dfs", "recorridos"]}
{"id": 10, "concepto": "Algoritmos de Grafos - BFS", "pregunta": "¿Qué es BFS y cómo funciona?", "respuesta": "BFS (Breadth-First Search) es un algoritmo de recorrido de grafos que explora todos los nodos vecinos a un nodo dado antes de pasar a los nodos vecinos de esos nodos. Utiliza una cola.", "dificultad": "medio", "tema": "grafos", "tags": ["grafos", "bfs", "recorridos"]}
{"id": 11, "concepto": "Algoritmo de ordenamiento Insertion Sort", "pregunta": "¿En qué casos es eficiente Insertion Sort?", "respuesta": "Insertion Sort es eficiente para listas pequeñas o listas que ya están casi ordenadas.", "dificultad": "facil", "tema": "ordenamiento", "tags": ["ordenamiento", "inserción", "eficiencia"]}
{"id": 12, "concepto": "Recursión - Caso Base", "pregunta": "¿Qué es un caso base en recursión?", "respuesta": "Un caso base es una condición que detiene la recursión.  Sin un caso base, la función recursiva se llamaría a sí misma indefinidamente, causando un error de desbordamiento de pila.", "dificultad": "facil", "tema": "estructuras de control", "tags": ["recursión", "caso base", "funciones"]}
{"id": 13, "concepto": "Algoritmo de ordenamiento Heap Sort", "pregunta": "¿Cómo funciona el Heap Sort?", "respuesta": "Heap Sort utiliza una estructura de datos de heap para ordenar la lista.  Construye un heap máximo y luego extrae repetidamente los elementos más grandes del heap.", "dificultad": "medio", "tema": "ordenamiento", "tags": ["ordenamiento", "heap sort", "eficiencia"]}
{"id": 14, "concepto": "Algoritmo de ordenamiento Radix Sort", "pregunta": "¿Cuándo es útil Radix Sort?", "respuesta": "Radix Sort es eficiente para ordenar enteros y cadenas de caracteres con un número limitado de dígitos (o caracteres).", "dificultad": "medio", "tema": "ordenamiento", "tags": ["ordenamiento", "radix", "eficiencia"]}
{"id": 15, "concepto": "Algoritmos de Grafos - Representación Adyacencia", "pregunta": "¿Qué es una matriz de adyacencia?", "respuesta": "Una matriz de adyacencia es una representación común de un grafo que usa una matriz para indicar si hay un arista entre cada par de nodos.", "dificultad": "medio", "tema": "grafos", "tags": ["grafos", "matriz de adyacencia"]}
{"id": 16, "concepto": "Recursión - Profundidad vs. Amplitud", "pregunta": "¿Cuál es la diferencia entre DFS y BFS?", "respuesta": "DFS explora la profundidad de cada rama antes de retroceder, mientras que BFS explora todos los nodos vecinos a un nodo dado antes de pasar a los nodos vecinos de esos nodos.", "dificultad": "medio", "tema": "estructuras de control", "tags": ["recursión", "dfs", "bfs"]}
{"id": 17, "concepto": "Algoritmo de ordenamiento Counting Sort", "pregunta": "¿Qué es Counting Sort y qué necesita?", "respuesta": "Counting Sort es un algoritmo de ordenamiento que se utiliza para ordenar enteros en un rango limitado.  Necesita conocer el rango de los valores.", "dificultad": "medio", "tema": "ordenamiento", "tags": ["ordenamiento", "contador", "eficiencia"]}
{"id": 18, "concepto": "Algoritmos de Grafos - Ciclos", "pregunta": "¿Cómo detectar ciclos en un grafo?", "respuesta": "Se pueden usar algoritmos como DFS o BFS con un mecanismo para marcar los nodos ya visitados.", "dificultad": "medio", "tema": "grafos", "tags": ["grafos", "ciclos", "detección"]}
{"id": 19, "concepto": "Algoritmo de ordenamiento Bucket Sort", "pregunta": "¿Qué es Bucket Sort y qué lo hace eficiente?", "respuesta": "Bucket Sort es eficiente cuando los elementos están distribuidos uniformemente en el rango de valores.  Utiliza una serie de contenedores (buckets) para ordenar los elementos.", "dificultad": "medio", "tema": "ordenamiento", "tags": ["ordenamiento", "bucket", "eficiencia"]}
{"id": 20, "concepto": "Recursión - Árboles Binarios", "pregunta": "¿Cómo se usa la recursión para recorrer un árbol binario?", "respuesta": "Se utiliza la recursión para explorar cada rama del árbol binario.", "dificultad": "medio", "tema": "estructuras de datos", "tags": ["recursión", "árboles", "árboles binarios"]}
{"id": 21, "concepto": "Algoritmo de ordenamiento Shell Sort", "pregunta": "¿Cómo funciona Shell Sort?", "respuesta": "Shell Sort es una versión mejorada del Insertion Sort que ordena elementos que están separados por una distancia 'h'", "dificultad": "medio", "tema": "ordenamiento", "tags": ["ordenamiento", "shell", "eficiencia"]}
{"id": 22, "concepto": "Algoritmos de Grafos - Caminos", "pregunta": "¿Qué son los caminos en un grafo?", "respuesta": "Un camino en un grafo es una secuencia de nodos conectados por aristas.", "dificultad": "facil", "tema": "grafos", "tags": ["grafos", "aristas", "ruta"]}
{"id": 23, "concepto": "Algoritmo de ordenamiento Bogo Sort", "pregunta": "¿Qué es Bogo Sort y por qué no es práctico?", "respuesta": "Bogo Sort es un algoritmo de ordenamiento aleatorio. Es extremadamente ineficiente y solo se utiliza como ejemplo.", "dificultad": "facil", "tema": "ordenamiento", "tags": ["ordenamiento", "aleatorio", "ineficiencia"]}
{"id": 24, "concepto": "Algoritmos de Grafos - Dijkstra y Colas de Prioridad", "pregunta": "¿Cómo se utiliza una cola de prioridad en el algoritmo de Dijkstra?", "respuesta": "Se utiliza una cola de prioridad para seleccionar eficientemente el nodo más cercano para expandir.", "dificultad": "medio", "tema": "grafos", "tags": ["grafos", "dijkstra", "cola de prioridad"]}
{"id": 25, "concepto": "Algoritmos de Grafos - DFS - Exploración", "pregunta": "¿Qué hace el algoritmo DFS?", "respuesta": "DFS es una forma de explorar un grafo o árbol a través de un bucle que recorre cada rama hasta que no quede ninguna más.", "dificultad": "medio", "tema": "grafos", "tags": ["grafos", "dfs", "recorridos"]}
{"id": 26, "concepto": "Algoritmos de Grafos - BFS - Exploración", "pregunta": "¿Qué hace el algoritmo BFS?", "respuesta": "BFS explora los nodos de un grafo o árbol visitando primero todos los vecinos de un nodo dado, luego visita a sus vecinos, y así sucesivamente.", "dificultad": "medio", "tema": "grafos", "tags": ["grafos", "bfs", "recorridos"]}
{"id": 27, "concepto": "Algoritmo de ordenamiento Merge Sort - Recursividad", "pregunta": "¿Cómo la recursión juega un papel en Merge Sort?", "respuesta": "Merge Sort utiliza recursividad para dividir la lista en sublistas más pequeñas y luego las combina.", "dificultad": "medio", "tema": "ordenamiento", "tags": ["ordenamiento", "merge sort", "eficiencia"]}
{"id": 28, "concepto": "Algoritmos de Grafos - Representación Adyacencia - Matriz", "pregunta": "¿Qué representa una matriz de adyacencia?", "respuesta": "Una matriz de adyacencia representa la conectividad de un grafo.", "dificultad": "facil", "tema": "grafos", "tags": ["grafos", "matriz de adyacencia"]}
{"id": 29, "concepto": "Algoritmos de Grafos - Ancho y Profundidad - Definiciones", "pregunta": "¿Qué son la profundidad y el ancho en un grafo?", "respuesta": "La profundidad es el número de pasos que se necesitan para ir de un nodo a otro. El ancho es el número de nodos en el mismo nivel.", "dificultad": "facil", "tema": "grafos", "tags": ["grafos", "dfs", "bfs"]}
{"id": 30, "concepto": "Algoritmo de ordenamiento Heap Sort - Heap", "pregunta": "¿Qué es un heap y cómo lo utiliza Heap Sort?", "respuesta": "Un heap es una estructura de datos de árbol que cumple con la propiedad de heap. Heap Sort utiliza un heap para ordenar los elementos.", "dificultad": "medio", "tema": "ordenamiento", "tags": ["ordenamiento", "heap sort", "eficiencia"]}
{"id": 31, "concepto": "Algoritmo de ordenamiento Bogo Sort - Ejemplo", "pregunta": "Bogo Sort - Ejemplo de un caso en el que podría funcionar (poco probable).", "respuesta": "Aunque es improbable, Bogo Sort podría funcionar en un caso donde la permutación aleatoria de los elementos resulta en una lista ordenada.", "dificultad": "facil", "tema": "ordenamiento", "tags": ["ordenamiento", "aleatorio", "ineficiencia"]}
