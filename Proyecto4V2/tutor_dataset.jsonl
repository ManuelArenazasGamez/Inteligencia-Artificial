{"instruction": "¿Qué es la complejidad temporal y por qué usamos la notación Big O?", "response": "La complejidad temporal mide cómo aumenta el tiempo de ejecución de un algoritmo a medida que crece el tamaño de la entrada (n). Usamos Big O (O) porque nos interesa la tasa de crecimiento (el comportamiento a gran escala) más que el tiempo exacto en segundos, que depende del hardware."}
{"instruction": "Explica la diferencia entre O(1) y O(n).", "response": "O(1) (tiempo constante) significa que el algoritmo tarda lo mismo sin importar si tienes 10 o 10 millones de datos (ej. acceder a un índice de un array). O(n) (tiempo lineal) significa que si duplicas los datos, el tiempo se duplica (ej. recorrer una lista con un bucle for)."}
{"instruction": "¿Cuál es el peor caso (Big O) de acceder a un elemento en una lista enlazada?", "response": "Es O(n). A diferencia de los arrays donde el acceso es directo por índice, en una lista enlazada debes recorrer los nodos uno por uno desde la cabeza hasta encontrar el elemento deseado."}
{"instruction": "Escribe una función en Python que sume todos los elementos de una lista. ¿Cuál es su complejidad?", "response": "```python\ndef sumar_lista(lista):\n    total = 0\n    for num in lista:\n        total += num\n    return total\n```\nSu complejidad es O(n) porque tiene que visitar cada elemento una vez."}
{"instruction": "¿Por qué es malo usar `lista.insert(0, x)` en Python repetidamente?", "response": "Porque insertar al inicio de una lista de Python requiere desplazar todos los demás elementos una posición a la derecha. Esto tiene una complejidad de O(n). Si lo haces n veces, tu algoritmo se vuelve O(n^2), lo cual es muy lento."}
{"instruction": "Implementa una función para invertir un string en Python de forma eficiente.", "response": "La forma más 'Pythonica' y eficiente es usando slicing:\n```python\ndef invertir_string(s):\n    return s[::-1]\n```\nEsto opera en O(n)."}
{"instruction": "¿Qué es un algoritmo 'In-Place'?", "response": "Un algoritmo es 'In-Place' (en el lugar) si transforma la entrada sin utilizar una cantidad significativa de memoria extra. Por ejemplo, Bubble Sort es in-place porque ordena intercambiando elementos dentro de la misma lista original, usando solo O(1) de memoria auxiliar."}
{"instruction": "Explica el concepto de 'Divide y Vencerás'.", "response": "Es una técnica de diseño de algoritmos que consiste en dividir un problema grande en subproblemas más pequeños del mismo tipo, resolverlos (a menudo recursivamente) y luego combinar sus soluciones para resolver el problema original. Ejemplos clásicos: Merge Sort y Quick Sort."}
{"instruction": "¿Cuál es la complejidad espacial de una función recursiva?", "response": "La complejidad espacial de una función recursiva está determinada por la profundidad máxima de la pila de llamadas (stack). Si la recursión va n niveles de profundidad, la complejidad espacial es O(n), incluso si no declaras variables nuevas, debido al espacio que ocupa cada llamada en memoria."}
{"instruction": "Tengo dos bucles anidados. ¿Cuál es la complejidad?\n```python\nfor i in range(n):\n    for j in range(n):\n        print(i, j)\n```", "response": "La complejidad es O(n^2) (Cuadrática). Por cada iteración del bucle externo (que ocurre n veces), el bucle interno se ejecuta n veces. Total de operaciones: n * n."}
{"instruction": "Escribe un Bubble Sort en Python.", "response": "```python\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n```\nComplejidad: O(n^2)."}
{"instruction": "¿Cómo funciona el Selection Sort?", "response": "El Selection Sort busca el elemento más pequeño de la lista y lo intercambia con el primer elemento no ordenado. Luego repite el proceso con el resto de la lista. Tiene complejidad O(n^2) pero realiza menos intercambios que el Bubble Sort."}
{"instruction": "Implementa Insertion Sort en Python.", "response": "```python\ndef insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i-1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n```\nEs eficiente para listas pequeñas o casi ordenadas (O(n) en el mejor caso)."}
{"instruction": "¿Cuál es la principal ventaja de Quick Sort sobre Merge Sort?", "response": "Quick Sort no requiere espacio extra adicional para arrays temporales (es in-place), mientras que Merge Sort necesita O(n) de memoria extra. Además, en la práctica, Quick Sort suele ser más rápido por tener constantes menores, aunque su peor caso es O(n^2)."}
{"instruction": "Explica el peor caso del Quick Sort.", "response": "El peor caso O(n^2) en Quick Sort ocurre cuando el pivote elegido es siempre el elemento más pequeño o más grande (ej. la lista ya está ordenada y eliges siempre el primero como pivote). Esto hace que la partición sea muy desbalanceada."}
{"instruction": "Escribe la función de partición para Quick Sort.", "response": "```python\ndef partition(arr, low, high):\n    i = (low-1)\n    pivot = arr[high]\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i = i+1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i+1], arr[high] = arr[high], arr[i+1]\n    return i+1\n```"}
{"instruction": "¿Por qué Merge Sort es un algoritmo estable?", "response": "Un algoritmo es estable si mantiene el orden relativo de elementos iguales. Merge Sort es estable porque, al mezclar dos sublistas, si encuentra elementos iguales, prefiere tomar el de la sublista izquierda (la que aparecía antes originalmente)."}
{"instruction": "Implementa la función 'merge' del Merge Sort.", "response": "```python\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n```"}
{"instruction": "¿Qué es un algoritmo de ordenamiento NO basado en comparaciones?", "response": "Son algoritmos como Counting Sort o Radix Sort. No comparan elementos entre sí (no preguntan '¿es A > B?'), sino que usan propiedades de los números (como su valor o sus dígitos) para ordenarlos. Pueden lograr O(n) bajo ciertas condiciones."}
{"instruction": "¿Cuál es el mejor algoritmo de ordenamiento para una lista casi ordenada?", "response": "Insertion Sort es excelente para esto. Si la lista está casi ordenada, su bucle interno apenas se ejecuta, logrando una complejidad cercana a O(n)."}
{"instruction": "Diferencia entre Búsqueda Lineal y Binaria.", "response": "La Lineal (O(n)) revisa elemento por elemento y funciona en listas desordenadas. La Binaria (O(log n)) divide el rango a la mitad repetidamente pero **requiere** que la lista esté ordenada."}
{"instruction": "Implementa Búsqueda Lineal en Python.", "response": "```python\ndef busqueda_lineal(arr, x):\n    for i in range(len(arr)):\n        if arr[i] == x:\n            return i\n    return -1\n```"}
{"instruction": "Implementa Búsqueda Binaria recursiva.", "response": "```python\ndef binary_search(arr, low, high, x):\n    if high >= low:\n        mid = (high + low) // 2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] > x:\n            return binary_search(arr, low, mid - 1, x)\n        else:\n            return binary_search(arr, mid + 1, high, x)\n    return -1\n```"}
{"instruction": "¿Qué pasa si aplicas Búsqueda Binaria a una lista desordenada?", "response": "El algoritmo fallará y dará resultados incorrectos. La lógica de 'descartar la mitad derecha o izquierda' se basa en la premisa de que los datos siguen un orden. Si no hay orden, descartar una mitad podría eliminar el elemento que buscas."}
{"instruction": "¿Qué es la búsqueda por interpolación?", "response": "Es una mejora de la búsqueda binaria para datos distribuidos uniformemente. En lugar de ir siempre al medio, estima la posición del valor basándose en qué tan cerca está de los extremos. Es similar a cómo buscas una palabra en un diccionario real."}
{"instruction": "Define una Estructura de Datos.", "response": "Es una forma particular de organizar y almacenar datos en una computadora para que puedan ser utilizados de manera eficiente. Diferentes estructuras son adecuadas para diferentes tipos de aplicaciones (ej. Grafos para mapas, Pilas para 'Deshacer')."}
{"instruction": "Implementa una Pila (Stack) usando una lista.", "response": "```python\nstack = []\nstack.append(1) # Push\nstack.append(2)\nelemento = stack.pop() # Pop (devuelve 2)\n```\nEn Python las listas funcionan eficientemente como pilas."}
{"instruction": "Implementa una Cola (Queue) usando collections.deque.", "response": "```python\nfrom collections import deque\nqueue = deque()\nqueue.append(1) # Enqueue\nqueue.append(2)\nitem = queue.popleft() # Dequeue eficiente O(1)\n```"}
{"instruction": "¿Qué es una Cola de Prioridad?", "response": "Es una estructura donde cada elemento tiene una 'prioridad' asociada. Al extraer un elemento, siempre sale el de mayor (o menor) prioridad, no necesariamente el que llegó primero. Se suele implementar con un Heap (Montículo)."}
{"instruction": "Muestra cómo usar heapq en Python para una cola de prioridad mínima.", "response": "```python\nimport heapq\nh = []\nheapq.heappush(h, 5)\nheapq.heappush(h, 1)\nheapq.heappush(h, 3)\n# Pop devuelve el menor: 1\nprint(heapq.heappop(h))\n```"}
{"instruction": "¿Qué es una Lista Enlazada Simple?", "response": "Una colección de nodos donde cada nodo contiene un dato y una referencia (puntero) al siguiente nodo. El último nodo apunta a None."}
{"instruction": "Define la clase Nodo para una lista enlazada.", "response": "```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n```"}
{"instruction": "Escribe un método para recorrer una lista enlazada e imprimir valores.", "response": "```python\ndef imprimir_lista(nodo_cabeza):\n    temp = nodo_cabeza\n    while temp:\n        print(temp.data)\n        temp = temp.next\n```"}
{"instruction": "¿Cómo insertar un nodo al inicio de una lista enlazada? (O(1))", "response": "```python\ndef push(cabeza, nuevo_dato):\n    nuevo_nodo = Node(nuevo_dato)\n    nuevo_nodo.next = cabeza\n    cabeza = nuevo_nodo\n    return cabeza\n```"}
{"instruction": "¿Qué es una Lista Doblemente Enlazada?", "response": "Es una lista donde cada nodo tiene referencias tanto al nodo siguiente como al nodo anterior. Esto permite recorrer la lista en ambas direcciones, pero ocupa más memoria por el puntero extra."}
{"instruction": "Detectar un ciclo en una lista enlazada (Algoritmo de Floyd).", "response": "Usamos dos punteros, uno lento (avanza 1 paso) y uno rápido (avanza 2 pasos). Si hay un ciclo, en algún momento el rápido alcanzará al lento.\n```python\ndef tiene_ciclo(head):\n    slow = head\n    fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False\n```"}
{"instruction": "¿Qué es un Árbol Binario?", "response": "Una estructura jerárquica donde cada nodo tiene como máximo dos hijos, llamados hijo izquierdo e hijo derecho."}
{"instruction": "¿Qué propiedad define a un Árbol de Búsqueda Binaria (BST)?", "response": "Para cualquier nodo, todos los elementos en su subárbol izquierdo son menores que él, y todos los elementos en su subárbol derecho son mayores. Esto permite búsquedas rápidas."}
{"instruction": "Implementa una búsqueda en un BST.", "response": "```python\ndef search(root, key):\n    if root is None or root.val == key:\n        return root\n    if root.val < key:\n        return search(root.right, key)\n    return search(root.left, key)\n```"}
{"instruction": "Explica el recorrido In-Order en un árbol.", "response": "Visita el subárbol izquierdo, luego la raíz, y finalmente el subárbol derecho. En un BST, este recorrido devuelve los valores ordenados de menor a mayor."}
{"instruction": "Código para recorrido In-Order.", "response": "```python\ndef in_order(root):\n    if root:\n        in_order(root.left)\n        print(root.val)\n        in_order(root.right)\n```"}
{"instruction": "Explica Pre-Order y Post-Order.", "response": "Pre-Order: Raíz -> Izquierda -> Derecha (útil para copiar árboles).\nPost-Order: Izquierda -> Derecha -> Raíz (útil para eliminar árboles o evaluar expresiones matemáticas)."}
{"instruction": "¿Qué es la profundidad de un árbol?", "response": "Es el número de aristas desde la raíz hasta el nodo hoja más lejano. Determina el peor caso de tiempo para operaciones de búsqueda."}
{"instruction": "¿Qué es un Grafo?", "response": "Un conjunto de nodos (vértices) conectados por enlaces (aristas). Pueden ser dirigidos (flechas) o no dirigidos, y ponderados (con valores en las aristas) o no."}
{"instruction": "¿Cómo se representa un grafo en Python?", "response": "Comúnmente usando un Diccionario de Listas (Lista de Adyacencia):\n```python\ngrafo = {\n    'A': ['B', 'C'],\n    'B': ['D'],\n    'C': [],\n    'D': ['A']\n}\n```"}
{"instruction": "Implementa BFS (Búsqueda en Anchura) en un grafo.", "response": "```python\ndef bfs(grafo, inicio):\n    visitados = set()\n    cola = [inicio]\n    while cola:\n        vertice = cola.pop(0)\n        if vertice not in visitados:\n            print(vertice)\n            visitados.add(vertice)\n            cola.extend(grafo[vertice])\n```"}
{"instruction": "Implementa DFS (Búsqueda en Profundidad) recursivo.", "response": "```python\ndef dfs(grafo, nodo, visitados=None):\n    if visitados is None:\n        visitados = set()\n    visitados.add(nodo)\n    print(nodo)\n    for vecino in grafo[nodo]:\n        if vecino not in visitados:\n            dfs(grafo, vecino, visitados)\n```"}
{"instruction": "¿Para qué sirve el algoritmo de Dijkstra?", "response": "Para encontrar el camino más corto desde un nodo origen a todos los demás nodos en un grafo con pesos positivos."}
{"instruction": "¿Qué es una Tabla Hash?", "response": "Una estructura que mapea claves a valores. Usa una función hash para calcular un índice en un array de 'cubos' o 'buckets' donde se almacena el valor. Permite búsquedas promedio en O(1)."}
{"instruction": "¿Qué es una colisión en una Tabla Hash?", "response": "Ocurre cuando la función hash asigna el mismo índice a dos claves diferentes. Se resuelven mediante encadenamiento (listas enlazadas en cada cubo) o direccionamiento abierto (buscar otro hueco)."}
{"instruction": "Crea un diccionario en Python y accede a un valor.", "response": "```python\nedades = {\"Ana\": 25, \"Luis\": 30}\nprint(edades[\"Ana\"]) # Imprime 25\n# Complejidad promedio O(1)\n```"}
{"instruction": "¿Cómo funciona `set` en Python?", "response": "Un `set` (conjunto) en Python se implementa internamente como una tabla hash con claves pero sin valores. Permite verificar pertenencia (`x in set`) en tiempo promedio O(1) y elimina duplicados automáticamente."}
{"instruction": "Explica la Recursividad con una analogía.", "response": "Es como las muñecas rusas (Matryoshka). Abres una muñeca y encuentras una versión más pequeña de la misma muñeca dentro. Sigues abriendo hasta encontrar la última, sólida (caso base), y luego cierras todas de regreso."}
{"instruction": "Calcula el Factorial recursivamente.", "response": "```python\ndef factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n-1)\n```"}
{"instruction": "Sucesión de Fibonacci recursiva (ineficiente).", "response": "```python\ndef fib(n):\n    if n <= 1: return n\n    return fib(n-1) + fib(n-2)\n```\nComplejidad O(2^n)."}
{"instruction": "Optimiza Fibonacci con Memoización.", "response": "```python\nmemo = {}\ndef fib_memo(n):\n    if n in memo: return memo[n]\n    if n <= 1: return n\n    memo[n] = fib_memo(n-1) + fib_memo(n-2)\n    return memo[n]\n```\nComplejidad baja a O(n)."}
{"instruction": "¿Qué es la Programación Dinámica?", "response": "Es un método para resolver problemas complejos dividiéndolos en subproblemas superpuestos más simples y almacenando sus resultados (memoización o tabulación) para no re-calcularlos."}
{"instruction": "Problema: Subir escaleras (Climbing Stairs). Puedes subir 1 o 2 escalones. ¿De cuántas formas llegas a N?", "response": "Es idéntico a Fibonacci. \n```python\ndef subir_escaleras(n):\n    a, b = 1, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n```"}
{"instruction": "Corrige este código: Bucle infinito en while.", "response": "Error:\n```python\ni = 0\nwhile i < 5:\n    print(i)\n```\nCorrección (Faltaba incremento):\n```python\ni = 0\nwhile i < 5:\n    print(i)\n    i += 1\n```"}
{"instruction": "Corrige este código: Modificar lista mientras se itera.", "response": "Error:\n```python\nnums = [1, 2, 3, 4]\nfor n in nums:\n    if n % 2 == 0:\n        nums.remove(n)\n```\nEsto salta elementos. Corrección (crear nueva lista):\n```python\nnums = [n for n in nums if n % 2 != 0]\n```"}
{"instruction": "¿Qué es un error 'IndexError'?", "response": "Ocurre cuando intentas acceder a una posición de una lista que no existe (ej. acceder al índice 10 en una lista de tamaño 5)."}
{"instruction": "¿Qué es un error 'RecursionError'?", "response": "Ocurre cuando una función se llama a sí misma demasiadas veces (generalmente por falta de un caso base), excediendo el límite de la pila de llamadas de Python."}
{"instruction": "¿Cómo depurarías un programa que se cierra inesperadamente?", "response": "1. Reproducir el error. 2. Leer el Traceback (mensaje de error). 3. Usar `print()` estratégicos para ver el estado de las variables antes del fallo o usar un debugger (como `pdb` en Python)."}
{"instruction": "Uso de assert en Python para depuración.", "response": "`assert` evalúa una condición; si es falsa, lanza un error. Es útil para verificar supuestos durante el desarrollo.\n```python\ndef dividir(a, b):\n    assert b != 0, \"El divisor no puede ser cero\"\n    return a / b\n```"}
{"instruction": "Diferencia entre `==` y `is` en Python.", "response": "`==` compara valores (¿son iguales los contenidos?), mientras que `is` compara identidad (¿son el mismo objeto en memoria?).\n`[1] == [1]` es True.\n`[1] is [1]` es False (son dos listas distintas)."}
{"instruction": "Explica el algoritmo de Euclides para MCD.", "response": "Calcula el Máximo Común Divisor de a y b. Se basa en que MCD(a, b) = MCD(b, a % b).\n```python\ndef mcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n```"}
{"instruction": "Genera números primos con la Criba de Eratóstenes.", "response": "```python\ndef criba(n):\n    primos = [True] * (n+1)\n    p = 2\n    while (p * p <= n):\n        if primos[p]:\n            for i in range(p * p, n+1, p):\n                primos[i] = False\n        p += 1\n    return [p for p in range(2, n) if primos[p]]\n```"}
{"instruction": "¿Cómo verificar si dos strings son Anagramas?", "response": "Ordenando ambos strings y comparándolos (O(n log n)) o contando frecuencias de caracteres con un hash map (O(n)).\n```python\nfrom collections import Counter\ndef son_anagramas(s1, s2):\n    return Counter(s1) == Counter(s2)\n```"}
{"instruction": "Problema Two Sum (Suma de Dos).", "response": "Dada una lista y un objetivo, encontrar índices de dos números que sumen el objetivo.\n```python\ndef two_sum(nums, target):\n    vistos = {}\n    for i, num in enumerate(nums):\n        diff = target - num\n        if diff in vistos:\n            return [vistos[diff], i]\n        vistos[num] = i\n```"}
{"instruction": "¿Qué es un algoritmo voraz (Greedy)?", "response": "Es una estrategia que toma la mejor decisión local en cada paso con la esperanza de llegar a la solución óptima global. Ejemplo: Dar cambio con la menor cantidad de monedas (funciona con sistemas de monedas estándar)."}
{"instruction": "Ejemplo simple de Greedy: Cambio de monedas.", "response": "```python\ndef cambio(monedas, cantidad):\n    monedas.sort(reverse=True)\n    contador = 0\n    for moneda in monedas:\n        while cantidad >= moneda:\n            cantidad -= moneda\n            contador += 1\n    return contador\n```"}
{"instruction": "Invierte las palabras en una oración.", "response": "```python\ndef invertir_palabras(oracion):\n    palabras = oracion.split()\n    palabras_invertidas = palabras[::-1]\n    return \" \".join(palabras_invertidas)\n```"}
{"instruction": "¿Qué es un Trie (Árbol de Prefijos)?", "response": "Es una estructura de árbol especial usada para almacenar strings dinámicos o arrays asociativos donde las claves son strings. Es muy eficiente para autocompletado y búsqueda de prefijos."}
{"instruction": "Operaciones bit a bit: Verificar si un número es par.", "response": "Usando el operador AND (&).\n```python\ndef es_par(n):\n    return (n & 1) == 0\n```\nEs más eficiente a nivel de procesador que `n % 2`."}
{"instruction": "Operaciones bit a bit: Multiplicar por 2.", "response": "Desplazar bits a la izquierda (`<<`) es equivalente a multiplicar por potencias de 2.\n`x << 1` es igual a `x * 2`."}
{"instruction": "¿Qué es el 'Sliding Window' (Ventana Deslizante)?", "response": "Es una técnica para problemas de arrays/strings donde buscas un subrango que cumpla cierta condición. Mueves una ventana de índices sobre los datos para evitar re-calcular todo. Reduce complejidad de O(n^2) a O(n)."}
{"instruction": "Ejemplo de Sliding Window: Suma máxima de sub-array de tamaño k.", "response": "```python\ndef max_sum_window(arr, k):\n    max_sum = sum(arr[:k])\n    temp_sum = max_sum\n    for i in range(len(arr) - k):\n        temp_sum = temp_sum - arr[i] + arr[i+k]\n        max_sum = max(max_sum, temp_sum)\n    return max_sum\n```"}
{"instruction": "¿Cómo fusionar dos listas ordenadas?", "response": "Es el paso clave del Merge Sort. Comparas cabezas y avanzas.\n```python\ndef fusionar(l1, l2):\n    res = []\n    while l1 and l2:\n        if l1[0] < l2[0]: res.append(l1.pop(0))\n        else: res.append(l2.pop(0))\n    res.extend(l1 or l2)\n    return res\n```"}
{"instruction": "Encuentra el número que falta en una secuencia del 1 al N.", "response": "Usa la fórmula de la suma de Gauss: `N*(N+1)/2`. Resta la suma real de la lista a la suma esperada.\n```python\ndef faltante(lista, n):\n    esperado = n * (n + 1) // 2\n    real = sum(lista)\n    return esperado - real\n```"}
{"instruction": "Validador de paréntesis balanceados con Pila.", "response": "```python\ndef balanceado(s):\n    pila = []\n    pares = {')': '(', ']': '[', '}': '{'}\n    for char in s:\n        if char in pares.values():\n            pila.append(char)\n        elif char in pares:\n            if not pila or pila.pop() != pares[char]:\n                return False\n    return len(pila) == 0\n```"}
{"instruction": "¿Qué significa que una lista en Python sea mutable?", "response": "Significa que puedes cambiar su contenido (agregar, borrar, modificar elementos) sin crear un nuevo objeto en memoria. Las tuplas y strings son inmutables."}
{"instruction": "¿Cómo clonar una lista profundamente (deep copy)?", "response": "Si la lista contiene otras listas, una copia simple `b = a[:]` solo copia referencias de las sublistas. Usa `copy.deepcopy`.\n```python\nimport copy\nb = copy.deepcopy(a)\n```"}
{"instruction": "Calcula la potencia de un número recursivamente (rápido).", "response": "Exponenciación rápida (Divide y Vencerás).\n```python\ndef potencia(base, exp):\n    if exp == 0: return 1\n    temp = potencia(base, exp // 2)\n    if exp % 2 == 0: return temp * temp\n    else: return base * temp * temp\n```\nComplejidad O(log n)."}
{"instruction": "¿Qué es Backtracking?", "response": "Es una técnica algorítmica para resolver problemas recursivamente probando construir una solución incrementalmente, y eliminando ('deshaciendo' o backtracking) aquellas que no satisfacen las condiciones. Ejemplo: Resolver un Sudoku."}
{"instruction": "Estructura para el problema de N-Reinas.", "response": "Se usa Backtracking. Se coloca una reina, se verifica si es seguro. Si sí, se avanza a la siguiente fila. Si no, se prueba otra posición. Si no hay posiciones, se regresa a la fila anterior."}
{"instruction": "¿Cómo eliminar duplicados de una lista manteniendo el orden?", "response": "```python\ndef unico_ordenado(lista):\n    vistos = set()\n    resultado = []\n    for x in lista:\n        if x not in vistos:\n            vistos.add(x)\n            resultado.append(x)\n    return resultado\n```"}
{"instruction": "Rotar una lista k veces a la derecha.", "response": "```python\ndef rotar(nums, k):\n    k = k % len(nums)\n    nums[:] = nums[-k:] + nums[:-k]\n```"}
{"instruction": "Mover ceros al final de la lista.", "response": "```python\ndef mover_ceros(nums):\n    pos = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[pos], nums[i] = nums[i], nums[pos]\n            pos += 1\n```"}
{"instruction": "Intersección de dos arrays.", "response": "```python\ndef interseccion(nums1, nums2):\n    return list(set(nums1) & set(nums2))\n```"}
{"instruction": "¿Qué es un Min-Heap?", "response": "Un árbol binario completo donde el valor de cada nodo es menor o igual que el de sus hijos. La raíz es siempre el elemento mínimo."}
{"instruction": "¿Cómo encontrar el k-ésimo elemento más grande de un array?", "response": "Puedes ordenar (O(n log n)) o usar un Min-Heap de tamaño k. Mantienes los k elementos más grandes en el heap; el tope será el k-ésimo mayor. (O(n log k))."}
{"instruction": "Validar si un string es un número válido.", "response": "Puedes usar `try-except` con `float()`.\n```python\ndef es_numero(s):\n    try:\n        float(s)\n        return True\n    except ValueError:\n        return False\n```"}
{"instruction": "Contar bits encendidos (Peso de Hamming).", "response": "```python\ndef hamming(n):\n    count = 0\n    while n:\n        n &= (n - 1) # Elimina el bit menos significativo\n        count += 1\n    return count\n```"}
{"instruction": "¿Qué es la notación polaca inversa (RPN)?", "response": "Es una notación matemática donde el operador sigue a los operandos (ej. `3 4 +` en lugar de `3 + 4`). Elimina la necesidad de paréntesis. Se evalúa fácilmente usando una Pila."}
{"instruction": "Evaluar RPN con Pila.", "response": "```python\ndef evaluar_rpn(tokens):\n    pila = []\n    for t in tokens:\n        if t in '+-*/':\n            b, a = pila.pop(), pila.pop()\n            if t == '+': pila.append(a + b)\n            # ... otros operadores\n        else:\n            pila.append(int(t))\n    return pila[0]\n```"}
{"instruction": "¿Qué es memoización?", "response": "Es una técnica de optimización que consiste en almacenar los resultados de llamadas a funciones costosas y devolver el resultado almacenado en caché cuando se repiten las mismas entradas."}
{"instruction": "Diferencia entre `sort()` y `sorted()`.", "response": "`lista.sort()` ordena la lista 'in-place' (modifica la original) y devuelve None. `sorted(lista)` crea y devuelve una nueva lista ordenada, dejando la original intacta."}
{"instruction": "Recorrido por niveles de un árbol (BFS).", "response": "```python\nfrom collections import deque\ndef level_order(root):\n    if not root: return []\n    cola = deque([root])\n    while cola:\n        nodo = cola.popleft()\n        print(nodo.val)\n        if nodo.left: cola.append(nodo.left)\n        if nodo.right: cola.append(nodo.right)\n```"}
{"instruction": "Encontrar el ancestro común más cercano (LCA) en BST.", "response": "```python\ndef lca(root, p, q):\n    if root.val > p and root.val > q:\n        return lca(root.left, p, q)\n    if root.val < p and root.val < q:\n        return lca(root.right, p, q)\n    return root\n```"}
{"instruction": "¿Qué es un algoritmo probabilístico?", "response": "Un algoritmo que utiliza números aleatorios para tomar decisiones lógicas. Ejemplo: Quick Sort con pivote aleatorio (reduce la probabilidad del peor caso O(n^2))."}
{"instruction": "Verificar si un árbol es simétrico (espejo).", "response": "```python\ndef es_espejo(t1, t2):\n    if not t1 and not t2: return True\n    if not t1 or not t2: return False\n    return (t1.val == t2.val) and es_espejo(t1.right, t2.left) and es_espejo(t1.left, t2.right)\n```"}
